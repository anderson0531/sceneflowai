/**
 * Audio Verification API
 * 
 * Endpoint to verify the authenticity and provenance of SceneFlow-generated audio.
 * Can verify via:
 * 1. Uploaded audio file (extracts embedded watermark)
 * 2. Verification token (from verification URL)
 */

import { NextRequest, NextResponse } from 'next/server'
import { AudioWatermarkService, AudioProvenanceData } from '@/services/AudioWatermarkService'

export async function POST(request: NextRequest) {
  try {
    const contentType = request.headers.get('content-type') || ''

    if (contentType.includes('audio/')) {
      // Direct audio file upload
      const audioData = Buffer.from(await request.arrayBuffer())
      const result = AudioWatermarkService.verifyAudio(audioData)

      return NextResponse.json({
        verified: result.valid,
        provenance: result.provenance ? {
          generator: result.provenance.generator,
          generatedAt: result.provenance.generatedAt,
          voiceType: result.provenance.voiceType,
          voiceName: result.provenance.voiceName,
          // Don't expose sensitive IDs
          isCloned: result.provenance.voiceType === 'cloned',
          hasConsent: !!result.provenance.cloneConsentId
        } : null,
        error: result.error
      })
    }

    // JSON body with verification data
    const body = await request.json()
    const { verificationData, audioBase64 } = body

    if (audioBase64) {
      // Base64 encoded audio
      const audioData = Buffer.from(audioBase64, 'base64')
      const result = AudioWatermarkService.verifyAudio(audioData)

      return NextResponse.json({
        verified: result.valid,
        provenance: result.provenance ? {
          generator: result.provenance.generator,
          generatedAt: result.provenance.generatedAt,
          voiceType: result.provenance.voiceType,
          voiceName: result.provenance.voiceName,
          isCloned: result.provenance.voiceType === 'cloned',
          hasConsent: !!result.provenance.cloneConsentId
        } : null,
        error: result.error
      })
    }

    if (verificationData) {
      // Verification token from URL
      try {
        const decoded = JSON.parse(
          Buffer.from(verificationData, 'base64url').toString('utf8')
        )
        
        // Create a minimal provenance object for signature verification
        const minimalProvenance: AudioProvenanceData = {
          version: '1.0',
          generator: 'sceneflow-ai',
          generatedAt: decoded.generatedAt,
          contentHash: decoded.contentHash,
          voiceType: 'stock', // Not stored in verification token
          voiceId: '',
          userId: '',
          textHash: ''
        }

        const isValid = AudioWatermarkService.verifySignature(minimalProvenance, decoded.signature)

        return NextResponse.json({
          verified: isValid,
          provenance: isValid ? {
            generator: 'sceneflow-ai',
            generatedAt: decoded.generatedAt,
            contentHash: decoded.contentHash
          } : null,
          error: isValid ? undefined : 'Invalid verification signature'
        })
      } catch {
        return NextResponse.json({
          verified: false,
          error: 'Invalid verification token format'
        }, { status: 400 })
      }
    }

    return NextResponse.json({
      error: 'Please provide audio file or verification data'
    }, { status: 400 })

  } catch (error) {
    console.error('[Audio Verify] Error:', error)
    return NextResponse.json({
      error: 'Verification failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

/**
 * GET handler for verification URL queries
 */
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const data = searchParams.get('data')

  if (!data) {
    return NextResponse.json({
      error: 'Missing verification data parameter'
    }, { status: 400 })
  }

  try {
    const decoded = JSON.parse(
      Buffer.from(data, 'base64url').toString('utf8')
    )

    const minimalProvenance: AudioProvenanceData = {
      version: '1.0',
      generator: 'sceneflow-ai',
      generatedAt: decoded.generatedAt,
      contentHash: decoded.contentHash,
      voiceType: 'stock',
      voiceId: '',
      userId: '',
      textHash: ''
    }

    const isValid = AudioWatermarkService.verifySignature(minimalProvenance, decoded.signature)

    return NextResponse.json({
      verified: isValid,
      generatedBy: 'SceneFlow AI',
      generatedAt: decoded.generatedAt,
      contentHash: decoded.contentHash,
      message: isValid 
        ? 'This audio was generated by SceneFlow AI and has not been tampered with.'
        : 'Verification failed - signature invalid or audio may have been modified.'
    })
  } catch {
    return NextResponse.json({
      verified: false,
      error: 'Invalid verification data'
    }, { status: 400 })
  }
}
